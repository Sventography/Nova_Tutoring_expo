import fs from "node:fs";
import path from "node:path";
import Stripe from "stripe";

const KEY = process.env.STRIPE_SECRET_KEY || "";
if (!KEY.startsWith("sk_")) {
  console.error("❌ STRIPE_SECRET_KEY missing. export sk_test_... first.");
  process.exit(1);
}
const stripe = new Stripe(KEY, { apiVersion: "2024-09-30.acacia" });

const ROOT = process.cwd();
const DEFAULT_OUT = "app/_lib/stripeProducts.ts";

// -------------------- file helpers --------------------
function walk(dir, acc=[]) {
  for (const e of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, e.name);
    if (e.isDirectory()) walk(p, acc);
    else if (/\.(ts|tsx|js|jsx)$/.test(e.name)) acc.push(p);
  }
  return acc;
}

function findCatalogFile() {
  const override = process.env.CATALOG_FILE;
  if (override && fs.existsSync(override)) return override;

  // Try common locations first
  const candidates = [
    "app/catalog.ts",
    "app/(tabs)/catalog.ts",
    "app/(tabs)/shop/catalog.ts",
  ].filter(p => fs.existsSync(p));
  if (candidates.length) return candidates[0];

  // Scan project for the export signature
  const files = walk(path.join(ROOT, "app"));
  for (const f of files) {
    try {
      const txt = fs.readFileSync(f, "utf8");
      if (txt.includes("export const catalog: CatalogItem[]")) return f;
      if (txt.includes("export const catalog") && txt.includes("CatalogItem"))
        return f;
    } catch {}
  }

  // As last resort, find any file that has "export const catalog"
  for (const f of files) {
    try {
      const txt = fs.readFileSync(f, "utf8");
      if (txt.includes("export const catalog")) return f;
    } catch {}
  }
  return null;
}

// -------------------- parse catalog --------------------
function extractItems(source) {
  // Grab item blocks { id: "...", title: "..." }
  const items = [];
  const re = /id:\s*"([^"]+)"[\s\S]*?title:\s*"([^"]+)"/g;
  for (const m of source.matchAll(re)) {
    items.push({ id: m[1], title: m[2] });
  }
  return items;
}

// -------------------- fuzzy match --------------------
function normWords(s) {
  return (s || "")
    .toLowerCase()
    .replace(/[\(\)\[\]\{\},.!?'"`~:;\\/|+_*^$#@-]/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .split(" ")
    .filter(Boolean);
}
function extractNums(s) { return (s.match(/\d+/g) || []).map(Number); }
function jaccard(aWords, bWords) {
  const A = new Set(aWords), B = new Set(bWords);
  const inter = [...A].filter(w => B.has(w)).length;
  const union = new Set([...A, ...B]).size || 1;
  return inter / union;
}
function scoreTitle(catTitle, prodName) {
  const wa = normWords(catTitle), wb = normWords(prodName);
  const base = jaccard(wa, wb);
  const na = extractNums(catTitle).join(","), nb = extractNums(prodName).join(",");
  const numBoost = na && nb && na === nb ? 0.25 : 0;
  const sub = prodName.toLowerCase().includes(catTitle.toLowerCase()) ? 0.15 : 0;
  return base + numBoost + sub;
}

// -------------------- stripe fetch --------------------
async function getAllProducts() {
  const out = [];
  let starting_after;
  do {
    const page = await stripe.products.list({ active: true, limit: 100, starting_after });
    out.push(...page.data);
    starting_after = page.has_more ? page.data.at(-1).id : undefined;
  } while (starting_after);
  return out;
}

// -------------------- main --------------------
(async () => {
  const catalogFile = findCatalogFile();
  if (!catalogFile) {
    console.error("❌ Could not find your catalog file. Set it explicitly like:");
    console.error("   CATALOG_FILE=app/(tabs)/yourCatalog.ts node scripts/generate-sku-map.mjs");
    process.exit(1);
  }
  const src = fs.readFileSync(catalogFile, "utf8");
  const entries = extractItems(src);
  if (!entries.length) {
    console.error(`❌ No {id,title} entries found in ${catalogFile}`);
    process.exit(1);
  }

  console.log(`• Catalog: ${catalogFile} (${entries.length} items)`);

  const products = await getAllProducts();
  console.log(`• Stripe products: ${products.length}`);

  // Build mapping
  const threshold = 0.38; // adjust if too strict/loose
  const mapping = {};
  for (const item of entries) {
    let best = { score: -1, product: null };
    for (const p of products) {
      const s = scoreTitle(item.title, p.name || "");
      if (s > best.score) best = { score: s, product: p };
    }
    if (best.product && best.score >= threshold) {
      mapping[item.id] = { pid: best.product.id, name: best.product.name, score: +best.score.toFixed(3) };
    } else {
      mapping[item.id] = { pid: "", name: "", score: +best.score.toFixed(3) };
    }
  }

  const productIdsList = [...new Set(products.map(p => p.id))];
  const skuUnion = entries.map(e => e.id);

  const out = `/**
 * AUTO-GENERATED by scripts/generate-sku-map.mjs
 * Source: ${path.relative(ROOT, catalogFile)}
 * Found ${entries.length} catalog items; matched ${Object.values(mapping).filter(v=>v.pid).length}.
 * Edit SKU_TO_PRODUCT_ID manually if any are incorrect.
 */

export const STRIPE_PRODUCT_IDS = ${JSON.stringify(productIdsList, null, 2)} as const;

type Sku = ${JSON.stringify(skuUnion, null, 2)}[number];

export const SKU_TO_PRODUCT_ID: Partial<Record<Sku, string>> = {
${entries.map(e => {
  const m = mapping[e.id];
  const comment = m.pid
    ? `// ✔ ${e.title} → ${m.name} (score ${m.score})`
    : `// TODO: ${e.title} (no confident match; score ${m.score})`;
  const line = m.pid
    ? `  "${e.id}": "${m.pid}", ${comment}`
    : `  // "${e.id}": "prod_...", ${comment}`;
  return line;
}).join("\n")}
};

export function resolveProductIdForSku(sku?: string | null): string | null {
  if (!sku) return null;
  const id = (SKU_TO_PRODUCT_ID as any)[sku];
  return typeof id === "string" && id.startsWith("prod_") ? id : null;
}
`;

  fs.writeFileSync(DEFAULT_OUT, out, "utf8");
  console.log(`✅ Wrote ${DEFAULT_OUT}`);
})();
