import { logQuizResult } from "../utils/log-quiz-result";
import { reportQuizFinished } from "../utils/report-quiz-finish";
import React, { useEffect, useMemo, useRef, useState } from "react";
import { View, Text, Pressable, ActivityIndicator, StyleSheet, ScrollView, Modal } from "react-native";
import { LinearGradient } from "expo-linear-gradient";
import { buildQuiz } from "../_lib/quiz";
import { getCardsById, toQA } from "../_lib/flashcards";
import { addEntry as logQuizFinish } from "../_lib/quizHistory";
import { useRouter } from "expo-router";

// üîπ new imports
import { createCertificate } from "../utils/certificates";
import { useUser } from "../context/UserContext";
import { showToast } from "../utils/toast";

type QItem = { question: string; choices: string[]; answer: string };

const QUIZ_LEN = 20;
const TOTAL_TIME = 300;
const ADVANCE_DELAY = 650;
const CYAN = "#00E5FF";
const BLUE = "#0B2239";
const BLACK = "#000000";
const NEON = "#39FF14";

export default function QuizScreen({ topicId = "abstract-algebra-intro", title = "Quiz" }: any) {
  const router = useRouter();
  const { user } = useUser();                         // üîπ who earned the cert

  const [loading, setLoading] = useState(true);
  const [items, setItems] = useState<QItem[]>([]);
  const [idx, setIdx] = useState(0);
  const [correct, setCorrect] = useState(0);
  const [selected, setSelected] = useState<number | null>(null);
  const [locked, setLocked] = useState(false);
  const [noData, setNoData] = useState(false);

  const [totalLeft, setTotalLeft] = useState(TOTAL_TIME);
  const [done, setDone] = useState(false);

  // NEW: modal when >=80
  const [showCert, setShowCert] = useState(false);

  // ensure history/cert is logged once per completion
  const loggedRef = useRef(false);
  const certSavedRef = useRef(false);                 // üîπ avoid duplicate cert saves

  const autoRef = useRef<NodeJS.Timeout | null>(null);
  const totalTimerRef = useRef<NodeJS.Timeout | null>(null);

  const current = items[idx];
  const total = items.length;
  const headerTitle = useMemo(() => (title ? String(title) : "Quiz"), [title]);

  useEffect(() => {
    const raw = getCardsById(String(topicId));
    const hasQA = raw.map(toQA).filter(Boolean) as {question: string; answer: string}[];
    if (!hasQA.length) { setNoData(true); setLoading(false); return; }
    const built = buildQuiz(raw as any, QUIZ_LEN);
    setItems(built);

    // reset session state
    setIdx(0); setCorrect(0); setSelected(null); setLocked(false);
    setDone(false); setTotalLeft(TOTAL_TIME); setNoData(false); setLoading(false);
    setShowCert(false);
    loggedRef.current = false;
    certSavedRef.current = false;
  }, [topicId]);

  useEffect(() => {
    if (loading || done || noData) return;
    if (totalTimerRef.current) clearInterval(totalTimerRef.current);
    totalTimerRef.current = setInterval(() => {
      setTotalLeft((t) => {
        if (t <= 1) {
          clearInterval(totalTimerRef.current as any);
          setDone(true);
          return 0;
        }
        return t - 1;
      });
    }, 1000);
    return () => { if (totalTimerRef.current) clearInterval(totalTimerRef.current); };
  }, [loading, done, noData]);

  // üîπ when quiz is done, log history (once) and trigger cert save + modal if >=80
  useEffect(() => {
useEffect(() => {n
  if (!done) return;n
n
  const pct = total ? Math.round((correct / total) * 100) : 0;n
n
  (async () => {n
    if (!loggedRef.current) {n
      try {n
        await logQuizResult({n
          topicId: String(topicId),n
          title: headerTitle,n
          total,n
          correct,n
          percent: pct,n
        });n
      } catch {}n
      loggedRef.current = true;n
    }n
n
    try {n
      await reportQuizFinished(pct, String(topicId));n
    } catch {}n
n
    if (pct >= 80 && !certSavedRef.current) {n
      certSavedRef.current = true;n
      try {n
        await createCertificate({n
          name: user?.username || "Student",n
          quizTitle: headerTitle,n
          scorePct: pct,n
        });n
        showToast(`üéì Certificate earned: ${headerTitle}`);n
      } catch {}n
      setShowCert(true);n
    }n
  })();n
}, [done, total, correct, headerTitle, topicId, user?.username]);
  function goNext() {
    if (idx + 1 >= total) { setDone(true); return; }
    setIdx((i) => i + 1);
    setSelected(null); setLocked(false);
  }
  function onPick(i: number) {
    if (locked || !current) return;
    setSelected(i); setLocked(true);
    if (current.choices[i] === current.answer) setCorrect((c) => c + 1);
    if (autoRef.current) clearTimeout(autoRef.current);
    autoRef.current = setTimeout(goNext, ADVANCE_DELAY);
  }
  function finishNow() { setDone(true); }

  const mm = Math.floor(totalLeft / 60);
  const ss = String(totalLeft % 60).padStart(2, "0");

  const Shell: React.FC<{children: React.ReactNode}> = ({children}) => (
    <LinearGradient colors={[BLACK, BLUE]} style={{flex:1}}>
      <ScrollView contentContainerStyle={S.container}>{children}</ScrollView>
    </LinearGradient>
  );

  const ViewCertificateButtons: React.FC<{pct:number}> = ({ pct }) => (
    <View style={S.row}>
      <Pressable style={[S.btn, S.outline]} onPress={()=>{
        // jump to Certificates tab (your generator lives there)
        try { router.navigate("/(tabs)/certificates"); } catch { router.push("/certificates" as any); }
      }}>
        <Text style={S.btnTxt}>View Certificate</Text>
      </Pressable>
    </View>
  );

  if (loading) return (
    <Shell>
      <View style={S.center}>
        <ActivityIndicator color={CYAN} />
        <Text style={[S.dim,{color:CYAN}]}>Loading {headerTitle}‚Ä¶</Text>
      </View>
    </Shell>
  );

  if (noData) return (
    <Shell>
      <Text style={S.title}>{headerTitle}</Text>
      <Text style={S.result}>No questions available.</Text>
    </Shell>
  );

  // Results
  if (done || !current) {
    const pct = total ? Math.round((correct / total) * 100) : 0;
    return (
      <Shell>
        <Text style={S.title}>{headerTitle}</Text>
        <Text style={S.result}>Score: {correct} / {total} ({pct}%).</Text>
        <View style={{height:12}} />
        {pct >= 80 && <ViewCertificateButtons pct={pct} />}
        <View style={{height:12}} />
        <View style={S.row}>
          <Pressable style={[S.btn, S.outline]} onPress={() => {/* navigate back if desired */}}>
            <Text style={S.btnTxt}>Topics</Text>
          </Pressable>
          <View style={{width:10}} />
          <Pressable
            style={[S.btn, S.solid]}
            onPress={() => {
              // restart quiz
              setIdx(0); setCorrect(0); setSelected(null); setLocked(false);
              setDone(false); setTotalLeft(TOTAL_TIME); setShowCert(false);
              loggedRef.current = false;
              certSavedRef.current = false;
            }}>
            <Text style={S.btnTxt}>Retry</Text>
          </Pressable>
        </View>

        {/* 80%+ modal */}
        <Modal visible={showCert} transparent animationType="fade" onRequestClose={()=>setShowCert(false)}>
          <View style={S.modalBackdrop}>
            <LinearGradient colors={["#001018", "#001F33", "#000"]} style={S.modalCard}>
              <Text style={S.modalTitle}>You scored {pct}% üéâ</Text>
              <Text style={S.modalBody}>80% or higher! Here‚Äôs your certificate.</Text>
              <View style={{height:12}} />
              <Pressable
                style={[S.btn, S.solid]}
                onPress={()=>{
                  setShowCert(false);
                  try { router.navigate("/(tabs)/certificates"); } catch { router.push("/certificates" as any); }
                }}>
                <Text style={S.btnTxt}>View / Download Certificate</Text>
              </Pressable>
              <View style={{height:10}} />
              <Pressable style={[S.btn, S.outline]} onPress={()=>setShowCert(false)}>
                <Text style={S.btnTxt}>Close</Text>
              </Pressable>
            </LinearGradient>
          </View>
        </Modal>
      </Shell>
    );
  }

  // In-quiz UI
  return (
    <Shell>
      <View style={S.row}>
        <Text style={S.title}>{headerTitle}</Text>
        <Text style={[S.meta, totalLeft <= 20 ? S.danger : undefined]}>‚è≥ {mm}:{ss}</Text>
      </View>
      <Text style={S.meta}>Question {idx + 1} / {total}</Text>
      <Text style={S.qText}>{current.question}</Text>

      <View style={{height:8}} />
      {current.choices.map((opt, i) => {
        const isPicked = selected === i;
        const isRight = locked && opt === current.answer;
        const isWrong = locked && isPicked && !isRight;
        return (
          <Pressable key={i} disabled={locked} onPress={() => onPick(i)}
            style={[S.choice, isPicked && S.choicePicked, isRight && S.choiceRight, isWrong && S.choiceWrong]}>
            <Text style={[S.choiceTxt, isRight && S.choiceTxtRight]}>{opt}</Text>
          </Pressable>
        );
      })}

      <View style={{height:12}} />
      <View style={S.row}>
        <Text style={S.meta}>Correct: {correct}</Text>
        <Text style={S.meta}>Remaining: {total - (idx + 1)}</Text>
      </View>

      <View style={{height:12}} />
      <View style={S.row}>
        <Pressable style={[S.btn, S.outline]} onPress={finishNow}>
          <Text style={S.btnTxt}>Finish</Text>
        </Pressable>
      </View>
    </Shell>
  );
}

export const S = StyleSheet.create({
  container: { padding: 16 },
  center: { flex: 1, alignItems: "center", justifyContent: "center" },
  dim: { opacity: 0.8 },
  title: { fontSize: 22, fontWeight: "800", color: CYAN, marginBottom: 4 },
  qText: { fontSize: 18, color: CYAN, marginTop: 6 },
  row: { flexDirection: "row", alignItems: "center", justifyContent: "space-between" },
  meta: { fontSize: 14, color: CYAN, opacity: 0.9 },
  danger: { color: "#ff6b6b", fontWeight: "800" },

  choice: { padding: 14, borderRadius: 10, borderWidth: 1.5, borderColor: CYAN, marginVertical: 6, backgroundColor: "rgba(0, 229, 255, 0.06)" },
  choicePicked: { backgroundColor: "rgba(0, 229, 255, 0.14)" },

  // ‚úÖ Neon green on correct
  choiceRight: {
    backgroundColor: "rgba(57, 255, 20, 0.22)",
    borderColor: NEON,
    shadowColor: NEON,
    shadowOpacity: 0.9,
    shadowRadius: 12,
    shadowOffset: { width: 0, height: 0 },
    elevation: 6,
  },
  choiceTxtRight: { color: NEON, fontWeight: "800" },

  choiceWrong: { backgroundColor: "rgba(255, 107, 107, 0.18)", borderColor: "#ff6b6b" },
  choiceTxt: { fontSize: 16, color: CYAN },

  btn: { paddingVertical: 12, paddingHorizontal: 18, borderRadius: 10, alignItems: "center", flex: 1 },
  btnTxt: { color: CYAN, fontWeight: "800", textAlign: "center" },
  solid: { backgroundColor: "rgba(0, 229, 255, 0.12)", borderWidth: 1.5, borderColor: CYAN },
  outline: { backgroundColor: "transparent", borderWidth: 1.5, borderColor: CYAN },
  result: { fontSize: 18, color: CYAN, marginTop: 6 },

  // Modal
  modalBackdrop: { position:"absolute", top:0, left:0, right:0, bottom:0, backgroundColor:"rgba(0,0,0,0.55)", alignItems:"center", justifyContent:"center", padding:16 },
  modalCard: { width:"100%", maxWidth:420, borderRadius:14, padding:16, borderWidth:1.5, borderColor:"rgba(0,229,255,0.5)" },
  modalTitle: { color:"#fff", fontSize:20, fontWeight:"800" },
  modalBody: { color:"#cfe", marginTop:8 },
});
